<link rel="import" href="../tangere/tangere.html">
<link rel="import" href="../at-theme/at-theme.html">
<link rel="import" href="../at-i18n/at-i18n-behavior.html">
<link rel="import" href="../at-form-behaviors/at-form-behaviors.html">
<link rel="import" href="at-form-text-input-validation.html">
<link rel="import" href="../iron-label/iron-label.html">
<!--
@element at-form-text
at-form-text represents an input type=text element on the form
-->

<dom-module id="at-form-text">
  <template>
    <style include="at-form-common"></style>
    <style>
      :host * {
        box-sizing: border-box;
      }

      :host {
        @apply(--at-form-host);
      }
    </style>

    <div id="atContainer" class="at-container">
      <iron-label id="label" for="input">{{label}}</iron-label>
      <div id="contentContainer" class="at-content-container">
        <input id="input" class="at-content has-placeholder" type="text" disabled$="{{disabled}}" placeholder$="{{placeholder}}">
      </div>
      <div id="hint"></div>
    </div>
  </template>
</dom-module>

<script>
  "use strict";
  Polymer({
    is: 'at-form-text',
    behaviors: [Tangere.behaviors.i18n, Tangere.behaviors.formUIGeneric, Tangere.behaviors.AtFormTextInputValidation ],
    properties: {
      /**
       * @property value
       * Element's required status for element validation purposes
       * this is achieved via autoamtic value-changed event
       * observer: 'valueChanged' outside world should be able to set/update the element's value
       * component is notified about this via valueChanged callback function
       */
      value: {
        type: String,
        value: '',
        observer: 'valueChanged',
        title: 'Value'
      },
      /**
       * @property hideLabel
       */

      hideLabel: {
        type: Boolean,
        value: false,
        observer: 'hideLabelChanged',
        title: 'Do not show the label'
      },

      /**
       * Element's required state for element validation purposes
       */
      required: {
        type: Boolean,
        value: false,
        observer: 'requiredChanged',
        title: 'Input required'
      },

      /**
       * Element's disabled state
       */
      disabled: {
        type: Boolean,
        value: false,
        observer: 'disabledChanged',
        title: 'Field value can not be changed'
      },

      /**
       * Element's label for element display purposes
       */
      label: {
        type: String,
        value: '',
        title: 'Label'
      },

      /**
       * Element's placeholder text for element display purposes
       */
      placeholder: {
        type: String,
        value: '',
        title: 'Placeholder text'
      },
      maxChars: {
        type: Number,
        value: 0,
        observer: 'maxCharsChanged',
        title: 'Maximum number of characters'
      },
      /**
       * Hides the element. When hidden nothing is displayed for the element
       * @property hide
       * @type Boolean
       * @default false
       */
      hide: {
        type: Boolean,
        value: false,
        observer: 'hideChanged',
        title: 'Field is invisible'
      }
    },
    $meta: [{
      title: "Text",
      type: "string",
      events: [ "value-changed" ]
    }],
    hideLabelChanged: function(newValue, oldValue) {
      var label = this.$.label;
      this.toggleClass("hidden", newValue, label);
    },
    hideChanged: function(newValue, oldValue) {
      var wrapper = this.$.atContainer;
      this.toggleClass('hidden', newValue, wrapper);
      if (this._isReady) {
        this.validate();
      }
    },
    ready: function() {

      var self = this;
      var valueProvider = this.$.input;

      valueProvider.addEventListener('change', function(e) {
        e.stopPropagation();
        self.value = valueProvider.value;
        self.validate();
        self._fireValueChangedEvent(self.value);
      });

      valueProvider.addEventListener('blur', function(e) {
        e.stopPropagation();
        self.validate();
      });

      valueProvider.addEventListener('keypress', function(event) {
        if (event.which === 13) {
          event.preventDefault();
        }
      });

      this._isReady = true;
    },

    disabledChanged: function(newValue, oldValue) {
      var container = this.$.atContainer;
      this.toggleClass('disabled', newValue, container);

      if (this._isReady) {
        this.validate();
      }
    },

    requiredChanged: function() {
      if (this._isReady) {
        this.validate();
      }
    },

    maxCharsChanged: function(newValue, oldValue) {
      if (this._isReady) {
        this.validate();
      }
    },

    focus: function() {
      this.$.input.focus();
    },

    valueChanged: function(newValue, oldValue) {
      if (this._validationResultHandlingInProgress) {
        return;
      }

      var valueProvider = this.$.input;

      if (newValue === null) {
        // if user sets at-form-text.value to null input should display initial value which is empty string
        valueProvider.value = this.properties.value.value;
      } else {
        valueProvider.value = newValue;
      }

      // when value changes due to user input or its changed programmatically
      // valid state should be updated and visual indication displayed
      // when valueChanged is called because value is set as attribute
      // that happens before ready function is called, so value-changed
      // should not be fired initially
      if (this._isReady) {
        this.validate();
        this._fireValueChangedEvent(newValue);
      }
    },

    validate: function () {
      if (this._validationResultHandlingInProgress) {
        return;
      }

      this._validationResultHandlingInProgress = true;
      /* (@ij on 28.07.2016 written for AT-162)
        update at-form-text.value for at-core-form-enter.keypress usecase
        consider following scenario
        1. at-form-text is child of at-core-form
        2. at-core-form listens to keypress event on its children with intent to validate itself when ENTER is pressed
        3. at-form-text.$.input has focus
        4. user types characters into input
        5. user presses ENTER
        6. at-core-form.keypress event handler is executed and ENTER is detected
        7. at-core-form.validate is executed; this executes validate on each child
        8. at-form-text.validate is executed
        9. at this point at-form-text.$.input change event didn't trigger and at-form-text.$.input blur event didn't trigger
        10. so at-form-text.value is not updated with the value from at-form-text.$.input
        11. this needs to be done before validation occurs for at least two reasons
        11.R1 its expected that at-form-text.validate operates on latest user input
        11.R2 its expected that at-core-form.data is already populated with lastest values from child elements when at-core-form.validate is called
        12. since at-form-text.$.input change/focus events didn't trigger and ENTER is pressed we detect that at-form-text.value needs to be updated by comparing
            at-form-text.value with at-form-text.$.input.value
        13. if they are different at-form-text.value should be updated with at-form-text.$.input.value

        14. now there is a special case where at-form.text.value is set to null;
        15. by setting at-form.text.value to null at-form-text.$.input.value is set to empty string
        16. if at-form-text.validate is called and at-form-text.value === null and at-form-text.$.input.value === "", at-form-text.value should not be updated
            because validation should operate on at-form-text.value === null. at-form-text.$.input.value is empty string because that should be displayed to the user
        17. if at-form.text.value was set to null but then user types into at-form.text.$.input and then presses ENTER then at-form-text.value should be updated
      */
      /*
        TAG P1

        @include into behavior  {
          No. This behavior is specific to single line input elements at-form- [ text, password, number, lookup and it should work for date]
          other elements either do not need this (checkbox) or
          it should work differently (file, image) or
          it can't happen because elements handle ENTER already (codemirror, markdown, textarea)
        }
      */
      var inputValue = this.$.input.value;
      if (this.value !== null && inputValue !== "" && inputValue !== this.value) {
        this.value = inputValue;
      }

      /*
        1. check disabled, hide and errorMessage first
        if any of these are set validating anything else is meaningless

        This can not be called from Tangere.behaviors.AtFormTextInputValidation because formUIGeneric is not availble in BOTS
       */
       /*
         TAG P1

         _validateBaseData comes from Tangere.behaviors.formUIGeneric
         _handleValidationResult comes from Tangere.behaviors.formUIGeneric
       */
      var validationResult = this._validateBaseData();
      this._handleValidationResult(validationResult);
      if (!validationResult.isValid) {
        return ;
      }

      /*
        2. check value type, required and element specific constraints
        We clone needed properties from this.properties because when used in BOTS
          - this.properties doesn't exist
          - properties must contain current value for required and maxChars; this.properties contains initial values
       */
       /*
         TAG P2

         _validateData comes from Tangere.behaviors.AtFormTextInputValidation
         _handleValidationResult comes from Tangere.behaviors.formUIGeneric
       */
      var properties = {
        value: JSON.parse(JSON.stringify(this.properties.value)),
        required: JSON.parse(JSON.stringify(this.properties.required)),
        maxChars: JSON.parse(JSON.stringify(this.properties.maxChars))
      };
      properties.value.type = this.properties.value.type; // assign this explicitly because functions can't be cloned with JSON stringify/parse pair
      properties.required.value = this.required;
      properties.maxChars.value = this.maxChars;

      validationResult = this._validateData(properties, this.value, this.T.bind(this));

      this._handleValidationResult(validationResult);

      this._validationResultHandlingInProgress = false;
    },

    // *ij* part of validation behavior API
    // include _updateUIValidState function and implement it to update
    // the UI to reflect the new valid state
    _updateUIValidState: function(isValid) {
      var label = this.$.label;
      this.toggleClass('error', !isValid, label);
      var contentContainer = this.$.contentContainer;
      this.toggleClass('error', !isValid, contentContainer);
    },

    // this function is part of the hint/validation API
    // hint should be displayed when element gains focus
    // behavior can not know when element gained focus
    // but if gived focusable element it can attach to its focus event
    // it should return focusable element if available or null if focusable element doesn't exist
    _getFocusableElement: function () {
      var focusable = this.$.input;
      return focusable;
    }
  });
</script>
