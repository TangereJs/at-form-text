<link rel="import" href="../tangere/tangere.html">
<link rel="import" href="../at-theme/at-theme.html">
<link rel="import" href="../at-i18n/at-i18n-behavior.html">
<link rel="import" href="../at-form-behaviors/at-form-behaviors.html">
<link rel="import" href="at-form-text-input-validation-behavior.html">
<link rel="import" href="../iron-label/iron-label.html">
<!--
@element at-form-text
at-form-text represents an input type=text element on the form
-->

<dom-module id="at-form-text">
  <template>
    <style include="at-form-common"></style>
    <style>
      :host * {
        box-sizing: border-box;
      }

      :host {
        @apply(--at-form-host);
      }
    </style>

    <div id="atContainer" class="at-container">
      <iron-label id="label" for="input">{{label}}</iron-label>
      <div id="contentContainer" class="at-content-container">
        <input id="input" class="at-content has-placeholder" type="text" disabled$="{{disabled}}" placeholder$="{{placeholder}}">
      </div>
      <div id="hint"></div>
    </div>
  </template>
</dom-module>

<script>
  "use strict";
  Polymer({
    is: 'at-form-text',
    behaviors: [Tangere.behaviors.i18n, Tangere.behaviors.formUIGeneric, Tangere.behaviors.AtFormTextInputValidation],
    properties: {
      /**
       * @property value
       * Element's required status for element validation purposes
       * this is achieved via autoamtic value-changed event
       * observer: 'valueChanged' outside world should be able to set/update the element's value
       * component is notified about this via valueChanged callback function
       */
      value: {
        type: String,
        value: '',
        observer: 'valueChanged',
        title: 'Value'
      },
      /**
       * @property hideLabel
       */

      hideLabel: {
        type: Boolean,
        value: false,
        observer: 'hideLabelChanged',
        title: 'Do not show the label'
      },

      /**
       * Element's required state for element validation purposes
       */
      required: {
        type: Boolean,
        value: false,
        observer: 'requiredChanged',
        title: 'Input required'
      },

      /**
       * Element's disabled state
       */
      disabled: {
        type: Boolean,
        value: false,
        observer: 'disabledChanged',
        title: 'Field value can not be changed'
      },

      /**
       * Element's label for element display purposes
       */
      label: {
        type: String,
        value: '',
        title: 'Label'
      },

      /**
       * Element's placeholder text for element display purposes
       */
      placeholder: {
        type: String,
        value: '',
        title: 'Placeholder text'
      },
      maxChars: {
        type: Number,
        value: 0,
        observer: 'maxCharsChanged',
        title: 'Maximum number of characters'
      },
      /**
       * Hides the element. When hidden nothing is displayed for the element
       * @property hide
       * @type Boolean
       * @default false
       */
      hide: {
        type: Boolean,
        value: false,
        observer: 'hideChanged',
        title: 'Field is invisible'
      }
    },
    $meta: [{
      title: "Text",
      type: "string",
      events: ["value-changed"]
    }],
    hideLabelChanged: function(newValue, oldValue) {
      var label = this.$.label;
      this.toggleClass("hidden", newValue, label);
    },
    hideChanged: function(newValue, oldValue) {
      var wrapper = this.$.atContainer;
      this.toggleClass('hidden', newValue, wrapper);
      if (this._isReady) {
        this.validate();
      }
    },
    ready: function() {

      var self = this;
      var valueProvider = this.$.input;

      valueProvider.addEventListener('change', function(e) {
        e.stopPropagation();
        self.validate();
      });

      valueProvider.addEventListener('blur', function(e) {
        e.stopPropagation();
        self.validate();
      });

      valueProvider.addEventListener('keypress', function(event) {
        if (event.which === 13) {
          event.preventDefault();
        }
      });

      this._isReady = true;
    },

    disabledChanged: function(newValue, oldValue) {
      var container = this.$.atContainer;
      this.toggleClass('disabled', newValue, container);

      if (this._isReady) {
        this.validate();
      }
    },

    requiredChanged: function() {
      if (this._isReady) {
        this.validate();
      }
    },

    maxCharsChanged: function(newValue, oldValue) {
      if (this._isReady) {
        this.validate();
      }
    },

    focus: function() {
      this.$.input.focus();
    },

    valueChanged: function(newValue, oldValue) {

      var valueProvider = this.$.input;

      if (newValue === null) {
        // if user sets at-form-text.value to null input should display initial value which is empty string
        valueProvider.value = this.properties.value.value;
      } else {
        valueProvider.value = newValue;
      }

      // when value changes due to user input or its changed programmatically
      // valid state should be updated and visual indication displayed
      // when valueChanged is called because value is set as attribute
      // that happens before ready function is called, so value-changed
      // should not be fired initially
      if (this._isReady) {
        this.validate();
        this._fireValueChangedEvent(this.value);
      }
    },

    validate: function () {

      if (this._validationResultHandlingInProgress) {
        return;
      }

      this._validationResultHandlingInProgress = true;

      // validate must validate the current value
      var inputValue = this.$.input.value;

      // this.value === null && inputValue === "" means that null value was set in code and user didn't type anything; in this case null value is validated
      // this.value !== null && inputValue ===  "" means that value is not null and user has cleared the input field; value of empty string is validated

      // this.value === null && inputValue !== "" means that null value was set in code and user has typed into input field
      // this.value !== null && this.value !== inputValue means that value is not null and user has typed into input field a new value which is different from the old one
      if ((this.value === null && inputValue !== "") || (this.value !== null && this.value !== inputValue)) {
        this.value = inputValue;
      }

      /*
        1. check disabled, hide and errorMessage first
        if any of these are set validating anything else is meaningless

        This can not be called from Tangere.behaviors.AtFormTextInputValidation because formUIGeneric is not availble in BOTS

         _validateBaseData comes from Tangere.behaviors.formUIGeneric
         _handleValidationResult comes from Tangere.behaviors.formUIGeneric
       */
      var validationResult = this._validateBaseData();
      this._handleValidationResult(validationResult);
      if (!validationResult.isValid) {
        this._validationResultHandlingInProgress = false;
        return validationResult.isValid;
      }

      /*
        2. check value type, required and element specific constraints

         _validateData comes from Tangere.behaviors.AtFormTextInputValidation
         _handleValidationResult comes from Tangere.behaviors.formUIGeneric
       */
      validationResult = this._validateData(this, this.value, this.T.bind(this));
      this._handleValidationResult(validationResult);

      this._validationResultHandlingInProgress = false;

      return validationResult.isValid;
    },

    // *ij* part of validation behavior API
    // include _updateUIValidState function and implement it to update
    // the UI to reflect the new valid state
    _updateUIValidState: function(isValid) {
      var label = this.$.label;
      this.toggleClass('error', !isValid, label);
      var contentContainer = this.$.contentContainer;
      this.toggleClass('error', !isValid, contentContainer);
    },

    // this function is part of the hint/validation API
    // hint should be displayed when element gains focus
    // behavior can not know when element gained focus
    // but if gived focusable element it can attach to its focus event
    // it should return focusable element if available or null if focusable element doesn't exist
    _getFocusableElement: function () {
      var focusable = this.$.input;
      return focusable;
    }
  });
</script>
